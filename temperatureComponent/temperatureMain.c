
#include "legato.h"
#include "interfaces.h" // This picks up the auto generated header files


le_event_Id_t temperatureMain_retrieveTemperatureChange_eventId(void);

/*
 * Legato IPC application wrapper for the temperature measurement system
 * The Probes take forever to carry out operations on the serial port
 * The current code blocks the thread of execution - we could work around this by recoding the borrowed 1-Wire code
 * Using IPC and a separate app means that the main app threads is not affected by the measurements
 */


/*
 * This is set in this app using le_event_CreateId when this app starts
 */
le_event_Id_t TempChangeEventId;




/*
 * Code with auto generated definitions - START
 *
 * Definitions for the STUFF are auto generated by the Legato tool chain
 * After a build definitions are possibly in teh following or something similar
 * _build_eventsBetweenComponents/wp85/api/<massiveUniqueId>/server/temperature_server.h
 *
 * A similar file is auto generated for the client to use
 * _build_eventsBetweenComponents/wp85/api/<differentMassiveUniqueId>/cleint/temperature_interface.h
 */

void temperature_RemoveIncomingMessageHandler
(
    temperature_IncomingMessageHandlerRef_t handlerRef
        ///< [IN]
)
{
	le_event_RemoveHandler((le_event_HandlerRef_t)handlerRef);
}



/*
 * first layer handler function
 * This is called when clients have called temperature_AddIncomingMessageHandler()
 *
 * The problem with this method is that as far as I can tell
 * 1. There is no way to automatically relate the payload coming (reportPtr) to the event payload - clientHandlerFunc (secondLayerHandlerFunc)
 * 2. So we end with a bodge where we have to create a struct for the incoming data
 * 3. Then hand mangle the input payload into the event payload (which is autodefined and hence checked)
 * 4. Which is immensely confusing to understand
 */

/*
 * ideally this structure needs to match (from temperature.api)
 *
 * HANDLER temperatureCbh
 * (
 *     string key[KEY_SIZE] IN,
 *     double value IN
 * );
 *
 * Note that KEY_SIZE has become TEMPERATURE_KEY_SIZE after auto generation
 */

struct temperaturePayload_stucture
{
	char keyString[TEMPERATURE_KEY_SIZE];
	double value;
};

void TempChangeHandler
(
    void* reportPtr,
    void* secondLayerHandlerFunc
)
{
	struct temperaturePayload_stucture *payload_struct;
	//= reportPtr ;
    //int32_t* temperaturePtr = reportPtr; // reportPtr;
    temperature_temperatureCbhFunc_t clientHandlerFunc = secondLayerHandlerFunc;

    LE_INFO("queue call to others %f", payload_struct->value );

    // send the data to the functions registered as secondLayerHandlerFunc
    clientHandlerFunc("h",1, le_event_GetContextPtr());
}

/*
 * Call this from a client to register handlerFunction_ptr to be called when TempChangeEventId is put on the event queue in this app / thread
 */

temperature_IncomingMessageHandlerRef_t temperature_AddIncomingMessageHandler
(
	temperature_temperatureCbhFunc_t handlerFunction_ptr,	// pointer to second layer handler function
	void* contextPtr
)
{
	le_event_HandlerRef_t handlerRef;  // temperature_IncomingMessageHandlerRef_t handlerRef;
    LE_INFO("called");
	/*
	 * Adds a layered handler function for a publish-subscribe event ID.
	 *
	 * Tells the calling thread event loop to call a specified handler function when a defined event reaches the front of the event queue.
	 * Passes the required handler functions when called.
	 */
	handlerRef = le_event_AddLayeredHandler("TempChange",			// name
											TempChangeEventId,		// local - le_event_Id_t > eventID
											TempChangeHandler,		// local - pointer to first layer handler function -- le_event_LayeredHandlerFunc_t
											handlerFunction_ptr);	// passed in - second-layer handler function- the event loop calls this when TempChangeHandler is called


	/*
	 * Sets the context pointer for a given event handler.
	 * This can later be retrieved using le_event_GetContextPtr() from within the handler function when it is called.
	 */
	le_event_SetContextPtr(handlerRef, contextPtr);	// ( le_event_HandlerRef_t handlerRef, void * contextPtr )

	return  (temperature_IncomingMessageHandlerRef_t)handlerRef;
}

/*
 * Code with auto generated definitions - END
 */



/*
*   Read the temperature 
*   This is a dummy function to generate test data
*/
static void temperature_read(void)
{
    static int8_t temperatureFake = 0;
    struct temperaturePayload_stucture temperaturePayload;

	strncpy(temperaturePayload.keyString,"strKey", TEMPERATURE_KEY_SIZE);



    // Generate an event 
    // Other apps can subscribe to this event via the IPC
	// TempChangeHandler("test",0); //  call this via event loop


    temperaturePayload.value = temperatureFake;

    /*
     * In this app the following event reports queues the data onto the event queue in this app
     * When this apps event queue picks up this event it fires off event calls to any other apps event queues that
     * previously have registered interest by calling temperature_AddIncomingMessageHandler() via IPC to this app
     */

	le_event_Report(temperatureMain_retrieveTemperatureChange_eventId(), (void *) &temperaturePayload, sizeof(temperaturePayload));

    temperatureFake++;
}


/*
 * Timer stuff
 */
static le_timer_Ref_t temperatureUpdateTimerRef;


static void temperature_updateTimer_cbh(le_timer_Ref_t timerRef)
{
	temperature_read();
}

static void temperature_timer_init(void)
{
	temperatureUpdateTimerRef = le_timer_Create ("TEMPERATURE_UPDATE_TIMER");

    le_timer_SetHandler ( temperatureUpdateTimerRef, temperature_updateTimer_cbh);
    le_timer_SetRepeat( temperatureUpdateTimerRef, 0 );
    le_timer_SetMsInterval( temperatureUpdateTimerRef, 2000);
    le_timer_Start( temperatureUpdateTimerRef);
}

/*
* Timers - end  
*/




le_event_Id_t temperatureMain_retrieveTemperatureChange_eventId(void)
{
	return (TempChangeEventId);
}


COMPONENT_INIT
{
	// TempChangeEventId = le_event_CreateId("TempChange", sizeof(temperature_temperatureCbhFunc_t));
	TempChangeEventId = le_event_CreateId("TempChange", sizeof(temperaturePayload_stucture));
	temperature_timer_init();
}
